
FT232Test01.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .text         000002de  00000000  00000000  00000074  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .data         00000028  00800060  000002de  00000352  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  2 .comment      00000030  00000000  00000000  0000037a  2**0
                  CONTENTS, READONLY
  3 .note.gnu.avr.deviceinfo 00000040  00000000  00000000  000003ac  2**2
                  CONTENTS, READONLY
  4 .debug_aranges 00000088  00000000  00000000  000003ec  2**0
                  CONTENTS, READONLY, DEBUGGING
  5 .debug_info   00000e62  00000000  00000000  00000474  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_abbrev 00000880  00000000  00000000  000012d6  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_line   000006bf  00000000  00000000  00001b56  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_frame  0000015c  00000000  00000000  00002218  2**2
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_str    000004a3  00000000  00000000  00002374  2**0
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_loc    000005ba  00000000  00000000  00002817  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_ranges 00000098  00000000  00000000  00002dd1  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
   0:	12 c0       	rjmp	.+36     	; 0x26 <__ctors_end>
   2:	2a c0       	rjmp	.+84     	; 0x58 <__bad_interrupt>
   4:	29 c0       	rjmp	.+82     	; 0x58 <__bad_interrupt>
   6:	28 c0       	rjmp	.+80     	; 0x58 <__bad_interrupt>
   8:	27 c0       	rjmp	.+78     	; 0x58 <__bad_interrupt>
   a:	26 c0       	rjmp	.+76     	; 0x58 <__bad_interrupt>
   c:	25 c0       	rjmp	.+74     	; 0x58 <__bad_interrupt>
   e:	24 c0       	rjmp	.+72     	; 0x58 <__bad_interrupt>
  10:	23 c0       	rjmp	.+70     	; 0x58 <__bad_interrupt>
  12:	22 c0       	rjmp	.+68     	; 0x58 <__bad_interrupt>
  14:	21 c0       	rjmp	.+66     	; 0x58 <__bad_interrupt>
  16:	20 c0       	rjmp	.+64     	; 0x58 <__bad_interrupt>
  18:	1f c0       	rjmp	.+62     	; 0x58 <__bad_interrupt>
  1a:	1e c0       	rjmp	.+60     	; 0x58 <__bad_interrupt>
  1c:	1e c0       	rjmp	.+60     	; 0x5a <__vector_14>
  1e:	1c c0       	rjmp	.+56     	; 0x58 <__bad_interrupt>
  20:	1b c0       	rjmp	.+54     	; 0x58 <__bad_interrupt>
  22:	1a c0       	rjmp	.+52     	; 0x58 <__bad_interrupt>
  24:	19 c0       	rjmp	.+50     	; 0x58 <__bad_interrupt>

00000026 <__ctors_end>:
  26:	11 24       	eor	r1, r1
  28:	1f be       	out	0x3f, r1	; 63
  2a:	cf ed       	ldi	r28, 0xDF	; 223
  2c:	cd bf       	out	0x3d, r28	; 61

0000002e <__do_copy_data>:
  2e:	10 e0       	ldi	r17, 0x00	; 0
  30:	a0 e6       	ldi	r26, 0x60	; 96
  32:	b0 e0       	ldi	r27, 0x00	; 0
  34:	ee ed       	ldi	r30, 0xDE	; 222
  36:	f2 e0       	ldi	r31, 0x02	; 2
  38:	02 c0       	rjmp	.+4      	; 0x3e <__SP_L__+0x1>
  3a:	05 90       	lpm	r0, Z+
  3c:	0d 92       	st	X+, r0
  3e:	a8 38       	cpi	r26, 0x88	; 136
  40:	b1 07       	cpc	r27, r17
  42:	d9 f7       	brne	.-10     	; 0x3a <__do_copy_data+0xc>

00000044 <__do_clear_bss>:
  44:	20 e0       	ldi	r18, 0x00	; 0
  46:	a8 e8       	ldi	r26, 0x88	; 136
  48:	b0 e0       	ldi	r27, 0x00	; 0
  4a:	01 c0       	rjmp	.+2      	; 0x4e <.do_clear_bss_start>

0000004c <.do_clear_bss_loop>:
  4c:	1d 92       	st	X+, r1

0000004e <.do_clear_bss_start>:
  4e:	a8 38       	cpi	r26, 0x88	; 136
  50:	b2 07       	cpc	r27, r18
  52:	e1 f7       	brne	.-8      	; 0x4c <.do_clear_bss_loop>
  54:	77 d0       	rcall	.+238    	; 0x144 <main>
  56:	41 c1       	rjmp	.+642    	; 0x2da <_exit>

00000058 <__bad_interrupt>:
  58:	d3 cf       	rjmp	.-90     	; 0x0 <__vectors>

0000005a <__vector_14>:
	usart_transmit_bytes(pmsg->op, sizeof(pmsg->op));
	usart_puts("\r\n");
	usart_puts("val:");
	//usart_puts(itoa(msg->, buf, 10));
	usart_puts("\r\n");
}
  5a:	1f 92       	push	r1
  5c:	0f 92       	push	r0
  5e:	0f b6       	in	r0, 0x3f	; 63
  60:	0f 92       	push	r0
  62:	11 24       	eor	r1, r1
  64:	8f 93       	push	r24
  66:	9f 93       	push	r25
  68:	80 91 60 00 	lds	r24, 0x0060	; 0x800060 <__data_start>
  6c:	90 91 61 00 	lds	r25, 0x0061	; 0x800061 <__data_start+0x1>
  70:	01 97       	sbiw	r24, 0x01	; 1
  72:	90 93 61 00 	sts	0x0061, r25	; 0x800061 <__data_start+0x1>
  76:	80 93 60 00 	sts	0x0060, r24	; 0x800060 <__data_start>
  7a:	18 16       	cp	r1, r24
  7c:	19 06       	cpc	r1, r25
  7e:	6c f0       	brlt	.+26     	; 0x9a <__vector_14+0x40>
  80:	81 e0       	ldi	r24, 0x01	; 1
  82:	90 e0       	ldi	r25, 0x00	; 0
  84:	90 93 61 00 	sts	0x0061, r25	; 0x800061 <__data_start+0x1>
  88:	80 93 60 00 	sts	0x0060, r24	; 0x800060 <__data_start>
  8c:	8c b7       	in	r24, 0x3c	; 60
  8e:	87 50       	subi	r24, 0x07	; 7
  90:	8c bf       	out	0x3c, r24	; 60
  92:	98 b3       	in	r25, 0x18	; 24
  94:	81 e0       	ldi	r24, 0x01	; 1
  96:	89 27       	eor	r24, r25
  98:	88 bb       	out	0x18, r24	; 24
  9a:	9f 91       	pop	r25
  9c:	8f 91       	pop	r24
  9e:	0f 90       	pop	r0
  a0:	0f be       	out	0x3f, r0	; 63
  a2:	0f 90       	pop	r0
  a4:	1f 90       	pop	r1
  a6:	18 95       	reti

000000a8 <msg_get>:
  a8:	cf 93       	push	r28
  aa:	df 93       	push	r29
  ac:	00 97       	sbiw	r24, 0x00	; 0
  ae:	d1 f1       	breq	.+116    	; 0x124 <__stack+0x45>
  b0:	fb 01       	movw	r30, r22
  b2:	ec 01       	movw	r28, r24
  b4:	88 e0       	ldi	r24, 0x08	; 8
  b6:	de 01       	movw	r26, r28
  b8:	01 90       	ld	r0, Z+
  ba:	0d 92       	st	X+, r0
  bc:	8a 95       	dec	r24
  be:	e1 f7       	brne	.-8      	; 0xb8 <msg_get+0x10>
  c0:	43 e0       	ldi	r20, 0x03	; 3
  c2:	50 e0       	ldi	r21, 0x00	; 0
  c4:	62 e6       	ldi	r22, 0x62	; 98
  c6:	70 e0       	ldi	r23, 0x00	; 0
  c8:	ce 01       	movw	r24, r28
  ca:	f3 d0       	rcall	.+486    	; 0x2b2 <memcmp>
  cc:	89 2b       	or	r24, r25
  ce:	61 f1       	breq	.+88     	; 0x128 <__stack+0x49>
  d0:	43 e0       	ldi	r20, 0x03	; 3
  d2:	50 e0       	ldi	r21, 0x00	; 0
  d4:	66 e6       	ldi	r22, 0x66	; 102
  d6:	70 e0       	ldi	r23, 0x00	; 0
  d8:	ce 01       	movw	r24, r28
  da:	eb d0       	rcall	.+470    	; 0x2b2 <memcmp>
  dc:	89 2b       	or	r24, r25
  de:	31 f1       	breq	.+76     	; 0x12c <__stack+0x4d>
  e0:	43 e0       	ldi	r20, 0x03	; 3
  e2:	50 e0       	ldi	r21, 0x00	; 0
  e4:	6a e6       	ldi	r22, 0x6A	; 106
  e6:	70 e0       	ldi	r23, 0x00	; 0
  e8:	ce 01       	movw	r24, r28
  ea:	e3 d0       	rcall	.+454    	; 0x2b2 <memcmp>
  ec:	89 2b       	or	r24, r25
  ee:	01 f1       	breq	.+64     	; 0x130 <__stack+0x51>
  f0:	43 e0       	ldi	r20, 0x03	; 3
  f2:	50 e0       	ldi	r21, 0x00	; 0
  f4:	6e e6       	ldi	r22, 0x6E	; 110
  f6:	70 e0       	ldi	r23, 0x00	; 0
  f8:	ce 01       	movw	r24, r28
  fa:	db d0       	rcall	.+438    	; 0x2b2 <memcmp>
  fc:	89 2b       	or	r24, r25
  fe:	d1 f0       	breq	.+52     	; 0x134 <__stack+0x55>
 100:	43 e0       	ldi	r20, 0x03	; 3
 102:	50 e0       	ldi	r21, 0x00	; 0
 104:	62 e7       	ldi	r22, 0x72	; 114
 106:	70 e0       	ldi	r23, 0x00	; 0
 108:	ce 01       	movw	r24, r28
 10a:	d3 d0       	rcall	.+422    	; 0x2b2 <memcmp>
 10c:	89 2b       	or	r24, r25
 10e:	a1 f0       	breq	.+40     	; 0x138 <__stack+0x59>
 110:	43 e0       	ldi	r20, 0x03	; 3
 112:	50 e0       	ldi	r21, 0x00	; 0
 114:	66 e7       	ldi	r22, 0x76	; 118
 116:	70 e0       	ldi	r23, 0x00	; 0
 118:	ce 01       	movw	r24, r28
 11a:	cb d0       	rcall	.+406    	; 0x2b2 <memcmp>
 11c:	89 2b       	or	r24, r25
 11e:	71 f4       	brne	.+28     	; 0x13c <__stack+0x5d>
 120:	87 e0       	ldi	r24, 0x07	; 7
 122:	0d c0       	rjmp	.+26     	; 0x13e <__stack+0x5f>
 124:	80 e0       	ldi	r24, 0x00	; 0
 126:	0b c0       	rjmp	.+22     	; 0x13e <__stack+0x5f>
 128:	81 e0       	ldi	r24, 0x01	; 1
 12a:	09 c0       	rjmp	.+18     	; 0x13e <__stack+0x5f>
 12c:	83 e0       	ldi	r24, 0x03	; 3
 12e:	07 c0       	rjmp	.+14     	; 0x13e <__stack+0x5f>
 130:	84 e0       	ldi	r24, 0x04	; 4
 132:	05 c0       	rjmp	.+10     	; 0x13e <__stack+0x5f>
 134:	85 e0       	ldi	r24, 0x05	; 5
 136:	03 c0       	rjmp	.+6      	; 0x13e <__stack+0x5f>
 138:	86 e0       	ldi	r24, 0x06	; 6
 13a:	01 c0       	rjmp	.+2      	; 0x13e <__stack+0x5f>
 13c:	80 e0       	ldi	r24, 0x00	; 0
 13e:	df 91       	pop	r29
 140:	cf 91       	pop	r28
 142:	08 95       	ret

00000144 <main>:
//
//! main.
//
//=============================================================================
int main()
{
 144:	cf 93       	push	r28
 146:	df 93       	push	r29
 148:	cd b7       	in	r28, 0x3d	; 61
 14a:	dd 27       	eor	r29, r29
 14c:	c2 51       	subi	r28, 0x12	; 18
 14e:	cd bf       	out	0x3d, r28	; 61
	*/

	//======================================
	// port configuration.
	//======================================
	DDR_LED	 |= _BV(PORT_LED_BIT);		// LED制御ポートの該当BITを出力設定に。
 150:	b8 9a       	sbi	0x17, 0	; 23
	PORT_LED &= ~_BV(PORT_LED_BIT);		// PORT_LED_BITをLOに設定
 152:	c0 98       	cbi	0x18, 0	; 24

	DDR_PWM	 |= _BV(PORT_PWM_BIT);		// PWM出力ポートの該当BITを出力設定に。
 154:	ba 9a       	sbi	0x17, 2	; 23
	PORT_PWM &= ~_BV(PORT_PWM_BIT);		// PORT_PWM_BITをLOに設定
 156:	c2 98       	cbi	0x18, 2	; 24
	// COM0x1=0,COM0x0=0 => PWM出力無し
	// COM0x1=0,COM0x0=1 => 比較一致でトグル
	// COM0x1=1,COM0x0=0 => 比較一致でLO、BOTTMでHI　　※一般的
	// COM0x1=1,COM0x0=1 => 上記反転

	TCNT0	= 0;						// タイマ0カウンタの初期化
 158:	12 be       	out	0x32, r1	; 50
	TCCR0A	= 0b11000011;				// 高速PWM(PWM出力はOC0A(PB2))
 15a:	83 ec       	ldi	r24, 0xC3	; 195
 15c:	80 bf       	out	0x30, r24	; 48
	TCCR0B	= 0b00000101;				// クロックを1024分周
 15e:	85 e0       	ldi	r24, 0x05	; 5
 160:	83 bf       	out	0x33, r24	; 51
	
	OCR0A	= 256>>1;					// Timer0のA比較ﾚｼﾞｽﾀ(PWMのduty比=50%)
 162:	80 e8       	ldi	r24, 0x80	; 128
 164:	86 bf       	out	0x36, r24	; 54
	OCR0B	= COUNTER_LED_OP;			// Timer0のB比較ﾚｼﾞｽﾀ
 166:	89 ef       	ldi	r24, 0xF9	; 249
 168:	8c bf       	out	0x3c, r24	; 60

	TIMSK	= _BV(OCIE0B);				// [TCNT0のB比較]を有効化
 16a:	84 e0       	ldi	r24, 0x04	; 4
 16c:	89 bf       	out	0x39, r24	; 57
	//TIMSK	= _BV(OCIE0B)|_BV(TOIE0);	// [TCNT0のB比較][TCNT0のOVF]を有効化
	//======================================
	// usart configuration.
	//======================================
	usart_init();
 16e:	9d d0       	rcall	.+314    	; 0x2aa <usart_init>

	UCSRA	= 0;						// (USART Control and Status Register A):
 170:	1b b8       	out	0x0b, r1	; 11
	UCSRB	= _BV(RXEN)|_BV(TXEN);		// (USART Control and Status Register B):受信許可,送信許可(=>0b00011000)
 172:	88 e1       	ldi	r24, 0x18	; 24
 174:	8a b9       	out	0x0a, r24	; 10
	UCSRC	= 0b00000110;				// (USART Control and Status Register C):非同期、8bit長データ、パリティ無し
 176:	86 e0       	ldi	r24, 0x06	; 6
 178:	83 b9       	out	0x03, r24	; 3
	
	sei();
 17a:	78 94       	sei
int main()
{
	char	buf[sizeof(message)];
	char    opid;
	message	msg;
	status  stats	 = {0};
 17c:	b1 2c       	mov	r11, r1
 17e:	c1 2c       	mov	r12, r1
 180:	d1 2c       	mov	r13, r1
 182:	e1 2c       	mov	r14, r1
 184:	f1 2c       	mov	r15, r1
	initialize();									//!< 初期化

	while(1)
	{
		usart_recieve_bytes(buf, sizeof(buf));		//!< 受信
		opid = msg_get(&msg, buf);					//!< message解析
 186:	ce 01       	movw	r24, r28
 188:	09 96       	adiw	r24, 0x09	; 9
 18a:	9a 8b       	std	Y+18, r25	; 0x12
 18c:	89 8b       	std	Y+17, r24	; 0x11
}

static inline void status_update(status* pstats){
	pstats->mic += 1;
	pstats->vol += 2;
	pstats->mpw ^= 1;		// 反転
 18e:	33 24       	eor	r3, r3
 190:	33 94       	inc	r3
	initialize();									//!< 初期化

	while(1)
	{
		usart_recieve_bytes(buf, sizeof(buf));		//!< 受信
		opid = msg_get(&msg, buf);					//!< message解析
 192:	09 89       	ldd	r16, Y+17	; 0x11
 194:	1a 89       	ldd	r17, Y+18	; 0x12
			pmsg->val_i_a = MIN(MAX(0, pstats->mic), MIC_MAX);
			//pmsg->val_i_b = 0;
			//pmsg->val_i_c = 0;
			break;
		case MSG_OP_ID_MPW:
			pmsg->val_i_a = MIN(MAX(0, pstats->mpw), 1);
 196:	21 2c       	mov	r2, r1
{
	switch(opid)
	{
		case MSG_OP_ID_WAY:
			opid = MSG_OP_ID_IAM;
			memcpy(pmsg->op, MSG_OP_IAM, sizeof(pmsg->op));
 198:	0f 2e       	mov	r0, r31
 19a:	f9 e6       	ldi	r31, 0x69	; 105
 19c:	8f 2e       	mov	r8, r31
 19e:	f1 e6       	ldi	r31, 0x61	; 97
 1a0:	9f 2e       	mov	r9, r31
 1a2:	fd e6       	ldi	r31, 0x6D	; 109
 1a4:	af 2e       	mov	r10, r31
 1a6:	f0 2d       	mov	r31, r0
			memcpy(pmsg->val_c, APP_IDENTITY, sizeof(pmsg->val_c));
 1a8:	0f 2e       	mov	r0, r31
 1aa:	f6 e6       	ldi	r31, 0x66	; 102
 1ac:	4f 2e       	mov	r4, r31
 1ae:	fb e6       	ldi	r31, 0x6B	; 107
 1b0:	5f 2e       	mov	r5, r31
 1b2:	f1 e6       	ldi	r31, 0x61	; 97
 1b4:	6f 2e       	mov	r6, r31
 1b6:	f4 e6       	ldi	r31, 0x64	; 100
 1b8:	7f 2e       	mov	r7, r31
 1ba:	f0 2d       	mov	r31, r0
	
	initialize();									//!< 初期化

	while(1)
	{
		usart_recieve_bytes(buf, sizeof(buf));		//!< 受信
 1bc:	68 e0       	ldi	r22, 0x08	; 8
 1be:	ce 01       	movw	r24, r28
 1c0:	01 96       	adiw	r24, 0x01	; 1
 1c2:	4c d0       	rcall	.+152    	; 0x25c <usart_recieve_bytes>
		opid = msg_get(&msg, buf);					//!< message解析
 1c4:	be 01       	movw	r22, r28
 1c6:	6f 5f       	subi	r22, 0xFF	; 255
 1c8:	7f 4f       	sbci	r23, 0xFF	; 255
 1ca:	80 2f       	mov	r24, r16
 1cc:	91 2f       	mov	r25, r17
 1ce:	6c df       	rcall	.-296    	; 0xa8 <msg_get>
		
		//! msgが無効な場合はやり直し
		if(opid == MSG_OP_ID_NOP)
 1d0:	88 23       	and	r24, r24
 1d2:	a1 f3       	breq	.-24     	; 0x1bc <main+0x78>
	//usart_puts(itoa(msg->, buf, 10));
	usart_puts("\r\n");
}

static inline void status_update(status* pstats){
	pstats->mic += 1;
 1d4:	9f ef       	ldi	r25, 0xFF	; 255
 1d6:	c9 1a       	sub	r12, r25
 1d8:	d9 0a       	sbc	r13, r25
	pstats->vol += 2;
 1da:	22 e0       	ldi	r18, 0x02	; 2
 1dc:	e2 0e       	add	r14, r18
 1de:	f1 1c       	adc	r15, r1
	pstats->mpw ^= 1;		// 反転
 1e0:	b3 24       	eor	r11, r3

}

static inline char msg_make_response(message* pmsg, char opid, const status* pstats)
{
	switch(opid)
 1e2:	84 30       	cpi	r24, 0x04	; 4
 1e4:	b9 f0       	breq	.+46     	; 0x214 <main+0xd0>
 1e6:	28 f4       	brcc	.+10     	; 0x1f2 <main+0xae>
 1e8:	81 30       	cpi	r24, 0x01	; 1
 1ea:	41 f0       	breq	.+16     	; 0x1fc <main+0xb8>
 1ec:	83 30       	cpi	r24, 0x03	; 3
 1ee:	71 f0       	breq	.+28     	; 0x20c <main+0xc8>
 1f0:	e5 cf       	rjmp	.-54     	; 0x1bc <main+0x78>
 1f2:	85 30       	cpi	r24, 0x05	; 5
 1f4:	d1 f0       	breq	.+52     	; 0x22a <main+0xe6>
 1f6:	86 30       	cpi	r24, 0x06	; 6
 1f8:	11 f1       	breq	.+68     	; 0x23e <main+0xfa>
 1fa:	e0 cf       	rjmp	.-64     	; 0x1bc <main+0x78>
	{
		case MSG_OP_ID_WAY:
			opid = MSG_OP_ID_IAM;
			memcpy(pmsg->op, MSG_OP_IAM, sizeof(pmsg->op));
 1fc:	89 86       	std	Y+9, r8	; 0x09
 1fe:	9a 86       	std	Y+10, r9	; 0x0a
 200:	ab 86       	std	Y+11, r10	; 0x0b
			memcpy(pmsg->val_c, APP_IDENTITY, sizeof(pmsg->val_c));
 202:	4c 86       	std	Y+12, r4	; 0x0c
 204:	5d 86       	std	Y+13, r5	; 0x0d
 206:	6e 86       	std	Y+14, r6	; 0x0e
 208:	7f 86       	std	Y+15, r7	; 0x0f
 20a:	23 c0       	rjmp	.+70     	; 0x252 <main+0x10e>
			break;
		case MSG_OP_ID_VER:
			pmsg->val_i_a = 1;
 20c:	81 e0       	ldi	r24, 0x01	; 1
 20e:	8c 87       	std	Y+12, r24	; 0x0c
 210:	2d 86       	std	Y+13, r2	; 0x0d
 212:	1f c0       	rjmp	.+62     	; 0x252 <main+0x10e>
			//pmsg->val_i_b = 0;
			//pmsg->val_i_c = 0;
			break;
		case MSG_OP_ID_MIC:
			pmsg->val_i_a = MIN(MAX(0, pstats->mic), MIC_MAX);
 214:	9c 2d       	mov	r25, r12
 216:	8d 2d       	mov	r24, r13
 218:	c1 14       	cp	r12, r1
 21a:	24 e0       	ldi	r18, 0x04	; 4
 21c:	d2 06       	cpc	r13, r18
 21e:	10 f0       	brcs	.+4      	; 0x224 <main+0xe0>
 220:	9f ef       	ldi	r25, 0xFF	; 255
 222:	83 e0       	ldi	r24, 0x03	; 3
 224:	9c 87       	std	Y+12, r25	; 0x0c
 226:	8d 87       	std	Y+13, r24	; 0x0d
 228:	14 c0       	rjmp	.+40     	; 0x252 <main+0x10e>
			//pmsg->val_i_b = 0;
			//pmsg->val_i_c = 0;
			break;
		case MSG_OP_ID_MPW:
			pmsg->val_i_a = MIN(MAX(0, pstats->mpw), 1);
 22a:	8b 2d       	mov	r24, r11
 22c:	90 e0       	ldi	r25, 0x00	; 0
 22e:	18 16       	cp	r1, r24
 230:	19 06       	cpc	r1, r25
 232:	14 f4       	brge	.+4      	; 0x238 <main+0xf4>
 234:	81 e0       	ldi	r24, 0x01	; 1
 236:	92 2d       	mov	r25, r2
 238:	9d 87       	std	Y+13, r25	; 0x0d
 23a:	8c 87       	std	Y+12, r24	; 0x0c
 23c:	0a c0       	rjmp	.+20     	; 0x252 <main+0x10e>
			//pmsg->val_i_b = 0;
			//pmsg->val_i_c = 0;
			break;
		case MSG_OP_ID_VOL:
			pmsg->val_i_a = MIN(MAX(0, pstats->vol), VOL_MAX);
 23e:	9e 2d       	mov	r25, r14
 240:	8f 2d       	mov	r24, r15
 242:	e1 14       	cp	r14, r1
 244:	24 e0       	ldi	r18, 0x04	; 4
 246:	f2 06       	cpc	r15, r18
 248:	10 f0       	brcs	.+4      	; 0x24e <main+0x10a>
 24a:	9f ef       	ldi	r25, 0xFF	; 255
 24c:	83 e0       	ldi	r24, 0x03	; 3
 24e:	9c 87       	std	Y+12, r25	; 0x0c
 250:	8d 87       	std	Y+13, r24	; 0x0d
		opid = msg_make_response(&msg, opid, &stats);				//!< 受信データを元に返信データを作成
		
		//! 返信が必要であれば、返信する
		if(opid != MSG_OP_ID_NOP)
		{
			usart_transmit_bytes(&msg, (unsigned char)sizeof(msg));	//!< 返信データを送信 
 252:	68 e0       	ldi	r22, 0x08	; 8
 254:	ce 01       	movw	r24, r28
 256:	09 96       	adiw	r24, 0x09	; 9
 258:	19 d0       	rcall	.+50     	; 0x28c <usart_transmit_bytes>
 25a:	b0 cf       	rjmp	.-160    	; 0x1bc <main+0x78>

0000025c <usart_recieve_bytes>:
 * @param	(pdata) データ格納先
 * @param	(size) 出力サイズ(bytes)
 * @return	size
 */
 void usart_recieve_bytes(char *pdata, unsigned char size)
 {
 25c:	1f 93       	push	r17
 25e:	cf 93       	push	r28
 260:	df 93       	push	r29
 262:	ec 01       	movw	r28, r24
 264:	16 2f       	mov	r17, r22
	memset(pdata, 0, size);
 266:	46 2f       	mov	r20, r22
 268:	50 e0       	ldi	r21, 0x00	; 0
 26a:	60 e0       	ldi	r22, 0x00	; 0
 26c:	70 e0       	ldi	r23, 0x00	; 0
 26e:	2e d0       	rcall	.+92     	; 0x2cc <memset>

	while(size-->0)
 270:	9f ef       	ldi	r25, 0xFF	; 255
 272:	91 0f       	add	r25, r17
 274:	11 23       	and	r17, r17
 276:	31 f0       	breq	.+12     	; 0x284 <usart_recieve_bytes+0x28>
 * @brief	シリアル通信にて1byte受信する
 * @return	1byte
 */
static inline uint8_t usart_recieve( void )
{
	loop_until_bit_is_set(UCSRA, RXCIE);		// 受信完了待ち:受信が完了するとUCSRAのRXCIE(7bit)が1になる
 278:	5f 9b       	sbis	0x0b, 7	; 11
 27a:	fe cf       	rjmp	.-4      	; 0x278 <usart_recieve_bytes+0x1c>
	
	return UDR;
 27c:	8c b1       	in	r24, 0x0c	; 12
	{
		*pdata = usart_recieve();
 27e:	89 93       	st	Y+, r24
 */
 void usart_recieve_bytes(char *pdata, unsigned char size)
 {
	memset(pdata, 0, size);

	while(size-->0)
 280:	91 50       	subi	r25, 0x01	; 1
 282:	d0 f7       	brcc	.-12     	; 0x278 <usart_recieve_bytes+0x1c>
	{
		*pdata = usart_recieve();
		pdata++;
	}
 }
 284:	df 91       	pop	r29
 286:	cf 91       	pop	r28
 288:	1f 91       	pop	r17
 28a:	08 95       	ret

0000028c <usart_transmit_bytes>:
 * @return	none
 */
 void usart_transmit_bytes(const void *pdata, unsigned char size)
{
	const char* p = pdata;
	while( size-->0 )
 28c:	2f ef       	ldi	r18, 0xFF	; 255
 28e:	26 0f       	add	r18, r22
 290:	66 23       	and	r22, r22
 292:	41 f0       	breq	.+16     	; 0x2a4 <usart_transmit_bytes+0x18>
 294:	e8 2f       	mov	r30, r24
 296:	f9 2f       	mov	r31, r25
	{
		usart_transmit( *p );
 298:	81 91       	ld	r24, Z+
 * @param	送信データ
 * @return	none
 */
static inline void usart_transmit( uint8_t data )
{
	loop_until_bit_is_set(UCSRA, UDRIE);		// バッファ待機待ち:送信が完了しバッファが空になるとUCSRAのUDRIE(5bit)が1になる
 29a:	5d 9b       	sbis	0x0b, 5	; 11
 29c:	fe cf       	rjmp	.-4      	; 0x29a <usart_transmit_bytes+0xe>
	
	UDR = data;
 29e:	8c b9       	out	0x0c, r24	; 12
 * @return	none
 */
 void usart_transmit_bytes(const void *pdata, unsigned char size)
{
	const char* p = pdata;
	while( size-->0 )
 2a0:	21 50       	subi	r18, 0x01	; 1
 2a2:	d0 f7       	brcc	.-12     	; 0x298 <usart_transmit_bytes+0xc>
 * @brief	シリアル通信にて送信が完了するまで待機する
 * @return	none
 */
static inline void usart_flush( void )
{
	loop_until_bit_is_set(UCSRA, TXCIE);		// 送信完了待ち:送信が完了するとUCSRAのTXCIE(6bit)が1になる
 2a4:	5e 9b       	sbis	0x0b, 6	; 11
 2a6:	fe cf       	rjmp	.-4      	; 0x2a4 <usart_transmit_bytes+0x18>
		usart_transmit( *p );
		p++;
	}

	usart_flush();
}
 2a8:	08 95       	ret

000002aa <usart_init>:
void usart_init()
{
	//stdout = &usart_output;
	//stdin  = &usart_input;

	UBRRH	= UBRRH_VALUE;				// (USART Baud Rate Register Hi)
 2aa:	12 b8       	out	0x02, r1	; 2
	UBRRL	= UBRRL_VALUE;				// (USART Baud Rate Register Lo) ※2313データシートのP88,89を参照
 2ac:	83 e3       	ldi	r24, 0x33	; 51
 2ae:	89 b9       	out	0x09, r24	; 9
 2b0:	08 95       	ret

000002b2 <memcmp>:
 2b2:	fb 01       	movw	r30, r22
 2b4:	dc 01       	movw	r26, r24
 2b6:	04 c0       	rjmp	.+8      	; 0x2c0 <memcmp+0xe>
 2b8:	8d 91       	ld	r24, X+
 2ba:	01 90       	ld	r0, Z+
 2bc:	80 19       	sub	r24, r0
 2be:	21 f4       	brne	.+8      	; 0x2c8 <memcmp+0x16>
 2c0:	41 50       	subi	r20, 0x01	; 1
 2c2:	50 40       	sbci	r21, 0x00	; 0
 2c4:	c8 f7       	brcc	.-14     	; 0x2b8 <memcmp+0x6>
 2c6:	88 1b       	sub	r24, r24
 2c8:	99 0b       	sbc	r25, r25
 2ca:	08 95       	ret

000002cc <memset>:
 2cc:	dc 01       	movw	r26, r24
 2ce:	01 c0       	rjmp	.+2      	; 0x2d2 <memset+0x6>
 2d0:	6d 93       	st	X+, r22
 2d2:	41 50       	subi	r20, 0x01	; 1
 2d4:	50 40       	sbci	r21, 0x00	; 0
 2d6:	e0 f7       	brcc	.-8      	; 0x2d0 <memset+0x4>
 2d8:	08 95       	ret

000002da <_exit>:
 2da:	f8 94       	cli

000002dc <__stop_program>:
 2dc:	ff cf       	rjmp	.-2      	; 0x2dc <__stop_program>
